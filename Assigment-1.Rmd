---
title: "Assignment-1-Network-analysis"
author: "Mathias Flinta"
date: "11/10/2019"
output:
  html_document: 
    toc: TRUE
    toc_float: TRUE
    df_print: paged
    code_folding: hide
    number_sections: TRUE
---

# Set-up

This project is made to be read in html, so open the html file in your preferred webbrowser. As standard the code is hidden in this document, but you can show all by pressing the button "Code" in the top right of the document. You can also show individual chunks of code by pressing the buttons "Code" which are placed around in the document. 

Link for google colab:

Link for github (in case errors should occur): 

First i have some personal setup in my local R-Markdown on how i want to display warnings ect. 
```{r}
### Knitr options
knitr::opts_chunk$set(warning=FALSE,
                     message=FALSE,
                     fig.align="center"
                     )

options(warn=-1) # Hides all warnings, as the knitr options only work on local R-Markdown mode. 
```

I load my packages for doing the analysis. 
```{r}
library(knitr) # For knitr to html
library(rmarkdown) # For formatting the document
library(tidyverse) # Standard datasciewnce toolkid (dplyr, ggplot2 et al.)
library(data.table) # for reading in data ect. 
library(magrittr) # For advanced piping (%>% et al.)
library(igraph) # For network analysis
library(tidygraph) # For tidy-style graph manipulation
library(ggraph) # For ggplot2 style graph plotting
library(Matrix) # For some matrix functionality
library(ggforce) # Awesome plotting
library(kableExtra) # Formatting for tables

# I set a seed for reproduciability
set.seed(123)
```

# Introduction
In this assignment i will analyze a network from 21 managers of a high-tec company in the US. 

Each manager was asked to whom do you go to for **advice** and who is your **friend**, to whom do you **report** was taken from company documents. This forms the 3 binary variables in the dataset: Krack-High-Tec includes the following three 21x21 text matrices:

- ADVICE

- FRIENDSHIP

- REPORTS_TO

High-Tec-Attributes includes one 21x5 matrix.

- ID: Numeric ID of the manager

- AGE: The managers age (in years)

- TENURE: The length of service or tenure (in years)

- LEVEL: The level in the corporate hierarchy (coded 1,2 and 3; 1 = CEO, 2 = Vice President, 3 = manager)

- DEPT: The department (coded 1,2,3,4 with the CEO in department 0, ie not in a department)

# Creating the network

**Task**

Generate network objects for the companies organizational structure (reports to), friendship, advice
This networks are generated from the corresponding edgelists
Also attach node characteristics from the corresponding nodelist

## Loading the data

First we will load the data into R. I also rename the column names for the edge list. 
```{r}
node_attributes <- fread("https://raw.githubusercontent.com/SDS-AAU/M2-2019/master/notebooks/assignments/assignment_1/data/Krack-High-Tec-Attributes.csv")

edge_advice_raw <- fread("https://raw.githubusercontent.com/SDS-AAU/M2-2019/master/notebooks/assignments/assignment_1/data/Krack-High-Tec-edgelist-Advice.txt")

edge_friendship_raw <- fread("https://raw.githubusercontent.com/SDS-AAU/M2-2019/master/notebooks/assignments/assignment_1/data/Krack-High-Tec-edgelist-Friendship.txt")

edge_reports_to_raw <- fread("https://raw.githubusercontent.com/SDS-AAU/M2-2019/master/notebooks/assignments/assignment_1/data/Krack-High-Tec-edgelist-ReportsTo.txt")

Column_names <- c("from", "to", "edge")

colnames(edge_advice_raw) <- Column_names
colnames(edge_friendship_raw) <- Column_names
colnames(edge_reports_to_raw) <- Column_names
```

To get an understanding of the scope and structure of the data i get the dimensions of the edges of the advice data. It has 3 columns. Column 1 is the "from ID", column 2 is the "to ID" and column 3 is the binary nr. indicating the presence (=1) or absence (=0) of an edge. And it has 21x21=441 rows. 
```{r}
dim(edge_advice_raw)
```
In this case we need to do further preperation with the edge list, as we need to format it so that the row only exists if column 3 indicates presence of a connection. Otherwise all further analysis will just interpret it as every vertex being connected, as it does not read the 3 column. Therefore i filter all 3 edge lists, so that i remove rows where no edge exist. 

```{r}
edge_advice <- edge_advice_raw %>% 
  filter(edge == 1)

edge_friendship <- edge_friendship_raw %>% 
  filter(edge == 1)

edge_reports_to <- edge_reports_to_raw %>% 
  filter(edge == 1)
```

## From edgelist to network

I create my three networks. I have here decided to use the tbl_graph class, which is a thin wrapper around the igraph object. Here we can still use all the igraph function, but also apply the tidy methods. 
```{r}
g_advice <- tbl_graph(edges = edge_advice, nodes = node_attributes, directed = TRUE)
g_friendship <- tbl_graph(edges = edge_friendship, nodes = node_attributes, directed = TRUE)
g_reports_to <- tbl_graph(edges = edge_reports_to, nodes = node_attributes, directed = TRUE)
```

So now we have 3 different directed, unweighted networks, each displaying 3 different sides/perspectives of the same underlying relations between the 21 managers. 

# Analysis

## A: Network level characteristics

When working with network, it can be beneficial to analyze the network as a whole, before further specific analysis. To start of i do a plot off all three networks together, just to get a impression of how the networks are. Then i will calculate 3 key metrics: Density, transistivity, reciprocity for all 3 networks. These a key figures that can indicate more precisly the nature of the network. Then i will use this to answer the questions about the networks. 

Note: Make more fancy plot. Plot titles for each graph. 
```{r}
par(mfrow=c(1,3))
set.seed(123)
plot(g_advice)
set.seed(123)
plot(g_friendship)
set.seed(123)
plot(g_reports_to)
```

Just based on these plots, we can see some patterns. For the first graph based on the question, "to whom do you go to for **advice**", we see that most managers go to several other managers for advice, indicated by the many edges. For the second graph based on the question "who is your **friend**?", we see less edges than before. We also see that all managers have at least one friend, and it seems like most have a couple of friends. Also we see that it does not always go both ways indicated by the arrow in only one direction. The third graph based on the question, "to whom do you **report**" was taken from company documents, and here we see very few edges. All managers only reports to one other manager, indicating the chain of command in the company, leading up to one manager in the middle being the CEO. Now i will use the key figures from the below table to get further insights. 

```{r}
# Edge density
advice_density <- edge_density(g_advice)
friendship_density <- edge_density(g_friendship)
reports_to_density <- edge_density(g_reports_to)
# Transitivity
advice_trans <- transitivity(g_advice)
friendship_trans <- transitivity(g_friendship)
reports_to_trans <- transitivity(g_reports_to)
# Reciprocity
advice_reci <- reciprocity(g_advice)
friendship_reci <- reciprocity(g_friendship)
reports_to_reci <- reciprocity(g_reports_to)
# I make a matrix of the key metrics
key_metrics_vector <- c(advice_density, friendship_density, reports_to_density, 
                 advice_trans, friendship_trans, reports_to_trans, 
                 advice_reci, friendship_reci, reports_to_reci)
key_metrics_m <- matrix(round(key_metrics_vector, 3), 3, 3, byrow = TRUE)
# I give the matrix names
colnames(key_metrics_m) <- c("Advice", "Friendship", "Reports to")
rownames(key_metrics_m) <- c("Edge density", "Transitivity", "Reciprocity")
# I format it nicely in a table
kable(key_metrics_m) %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "float_right")
```

Note: Should i do random networks to control these relative numbers???

Edge density describes the portion of the potential connections in a network that are actual connections. For the advice network we see that the edge density is at `r round(advice_density, 3)`, which means that the managers on average ask almost 50% of the other managers for advice. The friendship network the edge density is at `r round(friendship_density, 3)`, which means that the managers on average are friends with about 25% of the other managers. The reports to network have a edge density at `r round(reports_to_density, 3)`, which is very low and indicates that there is only one chain of command. So overall we see that employess are more likely to have a advice-seeking relationsship than a friendship. 

Transistivity, also called the clustering coefficient. It measures the proportion of all possible triangles in the network that are closed. Triangles is if a edge exists between three given vertices. For the advice network we see it's at `r round(advice_trans, 3)`, indicating that about 74% of all ???

**Are friends of your friends also your friends? (how to do it???). How to understand. If i indicate a node as a friend, does the nodes he indicates as friends then indicate me as a friend?**

Reciprocity measures the likelihood of vertices in a directed network to be mutually linked. For the advice network we see it's at `r round(advice_reci, 3)`, indicating that about 47% of managers get advice from the same managers they ask for advice. For the friendship network we see almost the same level of reciprocity at `r round(friendship_reci, 3)`, which states that only 45% of managers have indicated other managers as friends, where that managers have indicated him as a friend aswell. This means that 55% of managers does not have mutual friendships, when asked for in this survey. Overall we could say that relationsships like friendship and advice are not likely to be reciprocal, as they are both less than 50%. Off course this might be caused by the respondents defining friendsship in different ways, but here we must read the research paper to get further insights to this. Reciprocity for the reports to network is 0%, as the chain of command only goes in one direction. 

## B: Node level characteristics

Who is most popular in the networks. Who is the most wanted friend, and advice giver?
To figure out who is the most popular i calculate the degree of incoming edges in the 2 networks friendship and advice. These can be said to be the most wanted friend or advicer. 

```{r}
g_advice_in <- degree(g_advice, mode = c("in"))
g_friendship_in <- degree(g_friendship, mode = c("in"))

# I make the data matrix with the most popular
popular_vector <- c(max(g_advice_in), max(g_friendship_in), which.max(g_advice_in), which.max(g_friendship_in))
popular_m <- matrix(popular_vector, 2, 2, byrow = TRUE)

# I give the matrix names
colnames(popular_m) <- c("Most popular advicer", "Most popular friend")
rownames(popular_m) <- c("Nr. of connections", "ID nr.")
# I format it nicely in a table
kable(popular_m) %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "float_right")
```
In this case we see that the most popular advicer and friend is the same persion with the ID nr. 2. This manager has 18 people asking him advice and 10 people consider him their friend. This is quite a lot in a network of 21 managers. 

Are managers in higher hirarchy more popular as friend, and advice giver?

- LEVEL: The level in the corporate hierarchy (coded 1,2 and 3; 1 = CEO, 2 = Vice President, 3 = manager)

I can plot this grouped by level to get a visual of it. I can also calculate the mean of degree in the 3 groupings. 


## C: Relational Characteristics

Are managers from the same 1. department, or on the same 2. hirarchy, 3. age, or 4. tenuere more likely to become friends or give advice? (hint: assortiativity related)
Are friends more likely to give each others advice?


Note???

To create networks on a higher level of aggregation, you want to aggregate the edgelist the corresponding level before creating a network.













# Basic concepts notes

The whole system: Network or graph
The elements: Nodes/Vertices
The connections: Edges or links

Network is a system of elements and connections between them. 

Edgelist: a dataframe that contains a minimum of two columns, one column of nodes that are the source of a connection and another column of nodes that are the target of the connection. The nodes in the data are identified by unique IDs.

If the distinction between source and target is meaningful, the network is directed. If the distinction is not meaningful, the network is undirected.

An edge list can also contain additional columns that describe attributes of the edges such as a magnitude aspect for an edge. If the edges have a magnitude attribute the graph is considered weighted (e.g., number of interactions, strenght of friendship).

A second popular form of network representation is the adjacency-matrix (also called socio-matrix). It is represented as a  ð‘›âˆ—ð‘›  matrix, where  ð‘›  stands for the number of elements of which their relationships should be represented. The value in the cell that intercepts row  ð‘›  and column  ð‘š  indicates if an edge is present (=1) or absent (=0).

Nodelist: Stores information about the nodes. 

Graph data: 

Remember removal of a node or edge can impact the rest of the network. 

# Technical parts

We mostly use igraph objects

Important commands. g is the graph. 

V(g): Inspects vertices

E(g): Inspects edges

%N>% activates nodes
%E>% activates edges

ex:

g %N>% filter(gender == "F")
Note that filtering nodes will simultaneously result in a filtering of edges.
OBS: Nodes can be isolated in a nework, while edges without an adjacent node cannot exist.

# Centralities
Measure a specific nodes centrality. 

**Degree centrality**: Number of edges adjacent to a node. 

**Eigenvector centrality**: weight a node's degree centrality by the centrality of the nodes adjacent to it (and their centrality in turn by their centrality). 

**Betweenness centrality**: Take every pair of the network and count how many times a node can interrupt the shortest paths (geodesic distance) between the two nodes of the pair. 

There is many more... 
Commands is "centrality_???"

# Clustering (Community detection)
Another common operation is to group nodes based on the graph topology, sometimes referred to as community detection based on its commonality in social network analysis.

# Network level (global)
**Edge density**: describes the portion of the potential connections in a network that are actual connections.

**Diameter**: It is the shortest distance between the two most distant nodes in the network. In other words, once the shortest path length from every node to all other nodes is calculated, the diameter is the longest of all the calculated path lengths.

**Mean distance**: The average shortest path between two nodes in a network. Also called geodesic. 

**Transitivity**: (also known as triads/triangles). So if a edge exists between three given vertices it's a triad. Transitivity is then equivalent to the proportion of all possible triangles in the network that are closed.

**Reciprocity**: Is a measure of the likelihood of vertices in a directed network to be mutually linked. 

**Assortativity**: This is a measure of how preferentially attached vertices are to other vertices with identical attributes. In other words

We often compare the above numbers to random networks of same amount of nodes and density. 

**Cliques**: Cliques are a network where all nodes are adjacent, meaning they are connected to all other nodes in the network. 


Small worlds are an interesting network structure, combining short path lenght betwen the nodes with a high clustering coefficient. That means, that we have small interconected clusters, which are in turn connected by gatekeepers (the edges we call bridges or structural holes).

# Multi-modal networks
Now its time to talk about an interesting type of networks, multi-modal. This means, a network has several "modes", meaning connects entities on different conceptual levels. The most commone one is a 2-mode (or bipartite) network. Examples could be an Author  â†’  Paper, Inventor  â†’  Patent, Member  â†’  Club network. Here, the elements in the different modes represent different things.

We can alalyse them in sepperation (and sometimes we should), but often its helpful to "project"" them onto one mode. Here, we create a node in one mode by joint association with another mode.










